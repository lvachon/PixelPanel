#include <Adafruit_Protomatter.h>
#include <Adafruit_LIS3DH.h>    // For accelerometer
#include <HTTPClient.h>
#include <WiFi.h>
#include <Fonts/FreeSansBold12pt7b.h>
#include "FFT_signal.h"
#include "FFT.h"
#include "analog.h"



#define BTN_DOWN 7
#define BTN_UP 6
#define numPoints 64
#define numModes 16

#define SAMPLE_SIZE FFT_N
#define SAMPLE_RATE 34910

const PROGMEM uint16_t noaaLogo[] = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x162,0x2c4,0x364,0x3e5,0x425,0x425,0x3e5,0x385,0x2c4,0x182,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x263,0x3e5,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x3e5,0x2a3,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x243,0x425,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x283,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2802,0x0,0x0,0x0,0x4804,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x364,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x385,0xa0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa009,0x800,0x0,0x0,0x4804,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x101,0x3c5,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x405,0x141,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa009,0x800,0x0,0x0,0x9808,0x800,0x9808,0x0,0x4003,0x5805,0x3803,0x7807,0x9808,0x3803,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc1,0x3c5,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x405,0xa0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa009,0x800,0x0,0x0,0x9808,0x0,0x9808,0x0,0x9008,0x800,0xa009,0x3803,0x4003,0xa009,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x861,0xb66,0x426,0x426,0x426,0x426,0x426,0x4d6d,0xa6b7,0x9e96,0x24c9,0x8e33,0xa6b6,0x4d6e,0x4d4d,0xa6b6,0x9654,0x24a9,0x9e96,0xa6b7,0x2cca,0x426,0x426,0x426,0x446,0x34eb,0x7d72,0x10a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa009,0x800,0x0,0x0,0x9808,0x0,0x4804,0x5004,0x9008,0x0,0xa009,0x3803,0x3803,0x3002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8c71,0xcf3a,0x2cca,0x426,0x426,0x426,0x426,0x75f1,0x75f2,0x9e96,0x75f2,0xc719,0x5d8f,0xa696,0xaed7,0x4d4d,0xc73a,0x6dd1,0xa696,0x8e33,0x6dd0,0x426,0x426,0x446,0x8e54,0xffff,0xffff,0xad55,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa009,0x8007,0x7806,0x4003,0x9808,0x0,0x0,0xc80b,0x4003,0x0,0x3803,0x9008,0x7806,0x4804,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x39c7,0xf7be,0xffff,0xe79c,0x3d0b,0x426,0x426,0x426,0x75f1,0x65d0,0x9654,0x75f2,0xbef9,0x454d,0xa696,0xaed7,0xd75b,0xefbd,0x6dd1,0xefbd,0xe79d,0x6dd0,0x426,0x446,0x8633,0xffff,0xffff,0xffff,0xffff,0x2965,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9cf3,0xffff,0xffff,0xffff,0xefbd,0x24a9,0x426,0x426,0x75f1,0x65d0,0x9654,0x75f1,0xcf5a,0x8633,0x9e96,0xaed7,0x350b,0xc719,0x6dd1,0x9674,0x7e12,0x6dd0,0x426,0x3d2c,0xf7df,0xffff,0xffff,0xffff,0xf7ff,0x1c8d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18e3,0xe71c,0xffff,0xffff,0xffff,0xffff,0xbef8,0x1467,0x426,0x3d0b,0x350b,0x4d4d,0x24ca,0x5d8f,0x8633,0x24ca,0x5d8f,0x1c88,0x65b0,0x3d0b,0x4d4d,0x3d2c,0x350b,0x446,0xd75b,0xffff,0xffff,0xffff,0xffff,0x6f16,0x60f,0xe2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x42ea,0xe7de,0xffff,0xffff,0xffff,0xffff,0xffff,0x9674,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x6dd1,0xffff,0xffff,0xffff,0xffff,0x9f59,0x650,0x650,0x2e7,0x0,0x2802,0x0,0x0,0x3002,0x0,0x0,0x2802,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1001,0x3803,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ea,0x1e92,0xc79c,0xffff,0xffff,0xffff,0xffff,0xffff,0x4d6e,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0xc67,0xdf7c,0xffff,0xffff,0xffff,0xd7bd,0xe71,0x650,0x650,0x4cc,0x0,0x7806,0x3002,0x0,0xd80c,0x2002,0x800,0xa009,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9808,0x0,0x2802,0x7006,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x4ec,0x650,0x1671,0xc79c,0xffff,0xffff,0xffff,0xffff,0xe79c,0x24ca,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x6dd0,0xffff,0xffff,0xffff,0xdfdd,0x1e92,0x650,0x650,0x650,0x5cf,0x0,0x4003,0x6806,0x3803,0x7806,0x6005,0x4003,0x6805,0x4804,0x7806,0x9808,0x2802,0x2802,0xa009,0x7806,0x4003,0x3002,0xc80b,0x7806,0x2802,0xb009,0x8007,0x7006,0x0,0x4804,0x7806,0x9808,0x3002,0x4804,0xa009,0x7807,0xa1,0x58e,0x650,0x650,0x2e93,0xdfbd,0xffff,0xffff,0xffff,0xffff,0xc73a,0xc67,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x1467,0xe7bd,0xffff,0xffff,0xdfde,0x2692,0x650,0x650,0x650,0x650,0x650,0x0,0x800,0xa009,0x7006,0x1801,0x8807,0x8007,0x2802,0xa809,0x3803,0x4804,0x9008,0x0,0x3003,0x7806,0xa009,0x0,0x9808,0x0,0x2802,0x8807,0x0,0x9008,0x800,0xa809,0x3803,0x4003,0x9008,0x4804,0x6806,0x0,0xe2,0x5ef,0x650,0x650,0x650,0x36b3,0xdfdd,0xffff,0xffff,0xffff,0xffff,0x9e75,0xc46,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x9e95,0xffff,0xffff,0xdfdd,0x2692,0x650,0x650,0x650,0x650,0x650,0x650,0x0,0x0,0xa809,0x8807,0x0,0x8807,0xa809,0x0,0xa809,0x3803,0x3803,0x2802,0x5805,0x5004,0x800,0xa809,0x0,0x9808,0x0,0x2802,0x7006,0x0,0x8807,0x1001,0xa809,0x3803,0x3803,0x2802,0x4804,0x5004,0x0,0xe2,0x5ef,0x650,0x650,0x650,0x650,0x2692,0xdfbd,0xffff,0xffff,0xffff,0xffff,0x9e75,0xc67,0x426,0x426,0x426,0x426,0x426,0x426,0x426,0x556e,0xffff,0xffff,0xc79c,0x1672,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x0,0x0,0x8007,0x9008,0x0,0x6806,0xa008,0x0,0x5004,0x9008,0x7806,0x3803,0x4003,0xa009,0x8807,0xa809,0x0,0xa009,0x8007,0x2802,0x7006,0x0,0x8807,0x1001,0x5004,0x8807,0x7806,0x4003,0x4804,0x5004,0x0,0xc2,0x5af,0x650,0x650,0x650,0x650,0x650,0x2e93,0xbf9b,0xffff,0xffff,0xffff,0xffff,0x9e95,0x1488,0x426,0x426,0x426,0x426,0x426,0x3d0c,0xefbd,0xf7ff,0x8f38,0x1671,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x61,0x4ed,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x6f17,0xd7bd,0xffff,0xffff,0xffff,0xe7bd,0x5d8f,0x24a9,0x1467,0x24a9,0x75f1,0xe7bd,0xaf7a,0x36b3,0x1671,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x5ef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40a,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x1672,0x6f17,0xaf7b,0xe7de,0xffff,0xffff,0xe7bd,0xcf3a,0xefbd,0xffff,0xe7de,0xc79c,0xbf9c,0x9f59,0x1671,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x4ed,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2a7,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x1672,0x7717,0xefde,0xffff,0xf7ff,0xbf9b,0x66f6,0x1672,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x348,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x122,0x5cf,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x651,0x2e93,0x6f17,0xaf7b,0xffff,0xffff,0xb77b,0x46d4,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x630,0x123,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9808,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x42b,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0xe71,0x8738,0xc79c,0xbf9c,0x8f38,0x2692,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x4ac,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa809,0x8007,0xa809,0x2802,0x8007,0x1801,0x0,0xa809,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e5,0x630,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x1a4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb00a,0x0,0x1801,0x8807,0x2002,0x7806,0x3002,0x6806,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x3ea,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x4ac,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa809,0x0,0x1000,0x8807,0x0,0x9808,0x8807,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe2,0x56e,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x5cf,0x102,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb80a,0x8007,0x9808,0x2802,0x0,0x5805,0x9008,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a4,0x5cf,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x610,0x184,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6806,0x2802,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x225,0x5ef,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x610,0x2a6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3002,0x5805,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1a4,0x56e,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x58e,0x205,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x102,0x40a,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x46b,0x102,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x225,0x46b,0x60f,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x650,0x60f,0x4ac,0x225,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x183,0x328,0x48c,0x56e,0x630,0x650,0x650,0x630,0x58e,0x4ac,0x348,0x184,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};



int dMode=5;

fft_config_t *real_fft_plan = fft_init(FFT_N, FFT_REAL, FFT_FORWARD, fft_input, fft_output);

uint8_t rgbPins[]  = {42, 41, 40, 38, 39, 37};
uint8_t addrPins[] = {45, 36, 48, 35, 21};
uint8_t clockPin   = 2;
uint8_t latchPin   = 47;
uint8_t oePin      = 14;


bool freshSwitch = true;


Adafruit_Protomatter matrix(
  64,          // Width of matrix (or matrix chain) in pixels
  4,           // Bit depth, 1-6
  1, rgbPins,  // # of matrix chains, array of 6 RGB pins for each
  4, addrPins, // # of address pins (height is inferred), array of pins
  clockPin, latchPin, oePin, // Other matrix control pins
  false);      // No double-buffering here (see "doublebuffer" example)

Adafruit_LIS3DH accel = Adafruit_LIS3DH();
const char* ssid = "Vachon";
const char* password = "51cypress";

#define width 64
#define height 32

long lastCheck = -300000;
String inbound = "None";
String outbound = "None";
int offsetX=0;
String oString = "Loading MBTA information...";


long frame=0;

struct Point {
  float x;
  float y;
  float vx;
  float vy;
  uint16_t color;
  uint16_t color2;
};

struct Point points[numPoints];

uint16_t hsv565(float h, float s, float v){
   while(h<0){
    h+=360;
  }
  while(h>=360){
    h-=360;
  }
  float c = s*v;
  float hn = h / 60.0;
  float hnm2 = hn;
  float m = 255*(v-c);
  
  while(hnm2>=2){
    hnm2-=2;
  }
  float x = c*(1-abs((hnm2)-1));
  int r=0;
  int g=0;
  int b=0;
  
  if(hn<1){
    r=c*255+m;
    g=x*255+m;
    b=0*255+m;
    return matrix.color565(r,b,g);
  }
  if(hn<2){
    r=x*255+m;
    g=c*255+m;
    b=0*255+m;
    return matrix.color565(r,b,g);
  }
  if(hn<3){
    r=0*255+m;
    g=c*255+m;
    b=x*255+m;
    return matrix.color565(r,b,g);
  }
  if(hn<4){
    r=0*255+m;
    g=x*255+m;
    b=c*255+m;
    return matrix.color565(r,b,g);
  }
  if(hn<5){
    r=x*255+m;
    g=0*255+m;
    b=c*255+m;
    return matrix.color565(r,b,g);
  }
  if(hn<6){
    r=c*255+m;
    g=0*255+m;
    b=x*255+m;
    return matrix.color565(r,b,g);
  }
  return matrix.color565(64,0,0);
}

const int numAnimFrames=48;
uint16_t animFrames[numAnimFrames][width*height];
int animFrame=0;

void setup() {
  // put your setup code here, to run once:
  fadcInit(1, A1);
  Serial.begin(115200);
  // Initialize matrix...
  ProtomatterStatus status = matrix.begin();
  Serial.print("Protomatter begin() status: ");
  Serial.println((int)status);
  if (!accel.begin(0x19)) {
    Serial.println("Couldn't find accelerometer");
  }
  accel.setRange(LIS3DH_RANGE_4_G);   // 2, 4, 8 or 16 G!
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  pinMode(BTN_DOWN,INPUT_PULLUP);
  pinMode(BTN_UP,INPUT_PULLUP);

  for(int i=0;i<numPoints;i++){
    points[i].x=i%width;
    points[i].y=i/width;
    points[i].vx = 0;
    points[i].vy = 0;
    points[i].color = hsv565(360*i/numPoints,1,1);
    points[i].color2 = hsv565(360*i/numPoints,1,0.25);
  }

 
}




void liveSat(String view){
  if(millis()-lastCheck>5*60000){
      matrix.drawRGBBitmap(0,0,noaaLogo,64,32);
      matrix.show();
      HTTPClient http;
      http.setTimeout(60000);
      String serverPath = "http://lucvachon.com/pixelPanelSatService.php?view="+view;
      Serial.println("FEtching...");
      http.begin(serverPath.c_str());
      
      matrix.drawPixel(0,height-1,matrix.color565(0,0,64));
      matrix.show();
      http.setTimeout(60000);
      int httpResponseCode = http.GET();
      uint8_t byt[6];
      http.getStream().read(byt,4);//Discard first [] bytes (for some reason)
      http.getStream().read(byt,3);//Discard first [] bytes (for some reason)
      for(int frame=0;frame<numAnimFrames;frame++){
        matrix.drawPixel(frame,height-1,hsv565(frame*10,1,1));
        matrix.show();
        for(int pixel=0;pixel<width*height;pixel++){
          http.getStream().read(byt,3);
          int r=(byt[0]-48)*4;
          int g=(byt[1]-48)*4;
          int b=(byt[2]-48)*4;
          animFrames[frame][pixel]=matrix.color565(r,b,g);  
        }
        /*if(frame%2){
          http.getStream().read(byt,4);
          //http.getStream().read(byt,4);
        }//Discard [] bytes every other frame (for some reason)
        */
      }
      animFrame=0;
      lastCheck=millis();
  }
  matrix.drawRGBBitmap(0,0,animFrames[animFrame],64,32);
  matrix.show();
  
  
  animFrame=(animFrame+1)%numAnimFrames;
  if(!animFrame){delay(2000);}
  delay(70);
}

char* string2char(String command){
    if(command.length()!=0){
        char *p = const_cast<char*>(command.c_str());
        return p;
    }
}

void getMBTA(){
  //https://api-v3.mbta.com/predictions?filter[route]=CR-Middleborough&filter[stop]=place-MM-0186&api_key=a5776a64cc384c219bd536a4d1246260&include=trip,vehicle
  int bright=63;
  if(oString==""){
    bright=16;
  }
  matrix.fillScreen(0);
  frame++;
  for(int i=0;i<width;i++){
    //matrix.fillRect(0,0,width,10,matrix.color565(bright,bright*2,0));
    matrix.drawLine(i,0,i,8,hsv565(270.0+10.0*sin(2*3.14159*i/width+frame/30.0),1,bright/63.0));
  }
  matrix.setTextSize(1);
  matrix.setTextWrap(false);
  matrix.setCursor(8, 1);
  matrix.setTextColor(matrix.color565(bright*4,bright*4,bright*4));
  matrix.println("Montello");
  matrix.setTextColor(matrix.color565(bright*4,0,bright*2));
  matrix.setCursor(offsetX,24);
  matrix.setFont(&FreeSansBold12pt7b);
  int16_t  x1, y1;
  uint16_t w, h;
  matrix.getTextBounds(string2char(oString), 0, 24, &x1, &y1, &w, &h);
  matrix.setTextSize(1);
  matrix.print(oString);
  matrix.setFont();
  offsetX-=1;
  
  if(-offsetX > w+width){
    offsetX=width;
    if(millis()-lastCheck>1*60000){
      HTTPClient http;
      String serverPath = "http://worldtimeapi.org/api/ip";
      http.begin(serverPath.c_str());
      int httpResponseCode = http.GET();
      String payload = http.getString();
      payload = payload.substring(payload.indexOf("datetime")+11,payload.indexOf("datetime")+30);
      Serial.print("TIME:");
      Serial.println(payload);
      int yr = payload.substring(0,4).toInt();//2023-02-19T17:59:54
      int mo = payload.substring(5,7).toInt();//01234567890123456789
      int da = payload.substring(8,10).toInt();
      int hr = payload.substring(11,13).toInt();
      int mn = payload.substring(14,16).toInt();
      int sc = payload.substring(17,19).toInt();
      Serial.println(String(hr)+":"+String(mn));
      http.end();
 
      //HTTPClient http2;
      serverPath = "http://lucvachon.com/mbta_pixels.php";//"https://api-v3.mbta.com/predictions?filter[route]=Red&filter[stop]=place-wlsta&api_key=a5776a64cc384c219bd536a4d1246260&include=trip,vehicle";
      Serial.print("A");
      http.begin(serverPath.c_str());
      Serial.print("B");
      httpResponseCode = http.GET();
      Serial.print("C");
      payload = http.getString();
      http.end();
      Serial.print("D");
      inbound = "None";
      outbound = "None";
      Serial.println(payload);
      while(payload.indexOf("arrival_time")>0){
           
        payload = payload.substring(payload.indexOf("arrival_time"));
        payload = payload.substring(payload.indexOf("T")+1);
        String temp = payload.substring(0,payload.indexOf("-"));
        int phr = temp.substring(0,2).toInt();
        int pmn = temp.substring(3,5).toInt();
        if(phr<hr){phr+=24;}
        Serial.print("PredTime:");
        Serial.println(temp.substring(3,5));
        Serial.println(String(phr)+":"+String(pmn));
        Serial.println(payload);
        if(payload.indexOf("direction_id\":1")>-1 && payload.indexOf("direction_id\":1")<payload.indexOf("track")){
          Serial.println("Inbound");
          if(inbound=="None"){inbound = String((phr-hr)*60+(pmn-mn))+"mins";}
        }else{
          Serial.println("Outbound");
          if(outbound=="None"){outbound = String((phr-hr)*60+(pmn-mn))+"mins";}
        }
      }
      
      lastCheck=millis();
      oString="";
      if(inbound!="None"){
        oString="Next inbound train in "+inbound;
      }
      if(outbound!="None"){
        if(inbound!="None"){oString+="            ";}
        oString+="Next outbound train in "+outbound;
      }
      
      
    }

    
  }
  matrix.show();
  delay(15);
}

void vapor(){
  matrix.fillScreen(0);
  //Draw sun
  int dia = height/2-4;
  for(int i=dia/2;i<dia;i+=1){
    int w = 0.5*dia*sin(3.14159*i/dia);
    float p = (i-dia/2.0)/(dia/2.0);
    //Mid to bottom
    matrix.drawLine(width/2-w,(i+2),width/2+w,(i+2),hsv565(360-120.0*p,1,1));
    //Mid to top
    matrix.drawLine(width/2-w,(dia+2)-i,width/2+w,(dia+2)-i,hsv565(0+60.0*p,1,1));
  }
  
  //Draw perpindick lines
  for(float x=0;x<width;x++){
    int xx = x+(x-width/2)*10;
    //if(xx<0 || xx>width){continue;}
    matrix.drawLine(x,height/2,xx,height,hsv565(300,0.25,1.0-(abs(width/2-x)/(width/2))));
  }
  
  //Draw horizon lines
  for(float y=height/2+0.1;y<height;y=y+(y-height/2)*1.5){
    matrix.drawLine(0,y,width,y,hsv565(300,1,0.5));
  }
  matrix.show();
  delay(60);
}



int gindex=0;
float lastgx=0;
float lastgy=0;
float lastgz=0;

void gMeter(bool text=false){
  sensors_event_t event;
  accel.getEvent(&event);
  float gx = event.acceleration.x;
  float gy = event.acceleration.y;
  float gz = event.acceleration.z;
  points[gindex].x=gx-lastgx;
  points[gindex].y=gy-lastgy;
  points[gindex].vx=gz-lastgz;
  
  lastgx=lastgx*0.99+gx*0.01;
  lastgy=lastgy*0.99+gy*0.01;
  lastgz=lastgz*0.99+gz*0.01;
  
  gindex=(gindex+1)%64;
  float maxG=0.1;
  for(int i=0;i<64;i++){
    if(abs(points[i].x)>maxG){
      maxG=abs(points[i].x);
    }
    if(abs(points[i].y)>maxG){
      maxG=abs(points[i].y);
    }
    if(abs(points[i].vx)>maxG){
      maxG=abs(points[i].vx);
    }
  }
  maxG = ceil(maxG/1.0)*1.0;
  matrix.fillScreen(0);
  
  uint8_t r[height];
  uint8_t g[height];
  uint8_t b[height];
  
  for(int i=0;i<64;i++){
    int x=(width-gindex+i)%width;
    int yX = (int)(16.0 + 16.0 * points[i].x/maxG);
    int yY = (int)(16.0 + 16.0 * points[i].y/maxG);
    int yZ = (int)(16.0 + 16.0 * points[i].vx/maxG);
    for(int j=0;j<height;j++){
      r[j]=0;
      b[j]=0;
      g[j]=0;
    }
    for(int j=16;j!=yX;){
      r[j]=0+(255*(16-j))/(16-yX);
      if(yX>16){j++;}
      else{j--;}
    }
    for(int j=16;j!=yY;){
      g[j]=0+(255*(16-j))/(16-yY);
      if(yY>16){j++;}
      else{j--;}
    }
    for(int j=16;j!=yZ;){
      b[j]=0+(255*(16-j))/(16-yZ);
      if(yZ>16){j++;}
      else{j--;}
    }
    for(int j=0;j<height;j++){
      matrix.drawPixel(x,j,matrix.color565(r[j],b[j],g[j]));
    }
    //matrix.drawLine(x,yX,x,16,matrix.color565(255,0,0));
    //matrix.drawLine(x,yY,x,16,matrix.color565(0,0,255));
    //matrix.drawLine(x,yZ,x,16,matrix.color565(0,255,0));
  }
  for(int g=0;g<=maxG;g+=5){
    int y = (int)(16.0+16.0*g/maxG);
    matrix.drawPixel(0,y,matrix.color565(255,255,255));
    matrix.drawPixel(width-1,y,matrix.color565(255,255,255));
    matrix.drawPixel(0,32-y,matrix.color565(255,255,255));
    matrix.drawPixel(width-1,32-y,matrix.color565(255,255,255));
  }
  
  
  //Serial.println(maxG);
  if(text){
    matrix.setTextColor(matrix.color565(255,0,0));
    matrix.setCursor(0,0);
    matrix.print(String(gx,1));
    matrix.setTextColor(matrix.color565(0,0,255));
    matrix.setCursor(0,height-8);
    matrix.print(String(gy,1));
    matrix.setTextColor(matrix.color565(0,255,0));
    matrix.setCursor(width-24,0);
    matrix.print(String(gz,1));
    matrix.setTextColor(matrix.color565(255,255,255));
    matrix.setCursor(width-24,height-8);
    matrix.print(String(maxG,1));
  }
  matrix.show();
  delay(15);
}



void balls(){
  sensors_event_t event;
  accel.getEvent(&event);
  matrix.fillScreen(0);
  
  for(int i=0;i<numPoints;i++){
    points[i].vx+=event.acceleration.x/1000;
    points[i].vy+=event.acceleration.y/1000;
   
    points[i].vx-=points[i].vx*0.025;  
    points[i].vy-=points[i].vy*0.025;
        
    points[i].x+=points[i].vx;
    points[i].y+=points[i].vy;
    
    if(points[i].x>=width){
      points[i].x-=width;
      points[i].vx = ((rand()&255)-width*2)/100.0;
      points[i].vy = ((rand()&255)-width*2)/100.0;
    }
    if(points[i].y>=height){
      points[i].y-=height;
      points[i].vx = ((rand()&255)-width*2)/100.0;
      points[i].vy = ((rand()&255)-width*2)/100.0;
    }
    if(points[i].x<0){
      points[i].x+=width;
      points[i].vx = ((rand()&255)-width*2)/100.0;
      points[i].vy = ((rand()&255)-width*2)/100.0;
    }
    if(points[i].y<0){
      points[i].y+=height;
      points[i].vx = ((rand()&255)-width*2)/100.0;
      points[i].vy = ((rand()&255)-width*2)/100.0;
    }
    matrix.drawPixel((int)(points[i].x),(int)(points[i].y),points[i].color);
  }
  matrix.show();
  delay(15);
  
}




void fluid(){
  sensors_event_t event;
  accel.getEvent(&event);
  matrix.fillScreen(0);
  
  for(int i=0;i<numPoints;i++){
    float ax=0;
    float ay=0;
    for(int j=0;j<numPoints;j++){
      if(j==i){continue;}
      float d = ((points[i].x-points[j].x)*(points[i].x-points[j].x)+(points[i].y-points[j].y)*(points[i].y-points[j].y));
      if(d<0.1){d=0.1;}
      float f = 0.05/d;
      float a = atan2(points[i].y-points[j].y,points[i].x-points[j].x);
      ax+=f*cos(a);
      ay+=f*sin(a);
    }
    
    points[i].vx+=ax+event.acceleration.x/100;
    points[i].vy+=ay+event.acceleration.y/100;
   
    points[i].vx-=points[i].vx*0.025;  
    points[i].vy-=points[i].vy*0.025;
        
    points[i].x+=points[i].vx;
    points[i].y+=points[i].vy;
    
    if(points[i].x>width){
      points[i].x=width-points[i].vx;
      points[i].vx *= -0.99;
    }
    if(points[i].y>height){
      points[i].y=height-points[i].vy;
      points[i].vy *= -0.99;
    }
    if(points[i].x<0){
      points[i].x=0-points[i].vx;
      points[i].vx *= -0.99;
    }
    if(points[i].y<0){
      points[i].y=0-points[i].vy;
      points[i].vy *= -0.99;
    }
    matrix.drawPixel((int)(points[i].x),(int)(points[i].y),points[i].color);
    if(points[i].x>0){
      matrix.drawPixel((int)(points[i].x)-1,(int)(points[i].y),points[i].color2);
    }
    if(points[i].x<width-1){
      matrix.drawPixel((int)(points[i].x)+1,(int)(points[i].y),points[i].color2);
    }
    if(points[i].y>0){
      matrix.drawPixel((int)(points[i].x),(int)(points[i].y)-1,points[i].color2);
    }
    if(points[i].y<height-1){
      matrix.drawPixel((int)(points[i].x),(int)(points[i].y)+1,points[i].color2);
    }
  }
  matrix.show();
  //delay(15);
}


float audioGain = 0.05f;

float audioNF = 1.0f;

float notepow(float n,bool raw=false){
  float freq = 27.5*pow(2,n/12.0);
  float freq2 = 27.5*pow(2,(n+1.4)/12.0);
  int j = (SAMPLE_SIZE*freq)/(SAMPLE_RATE);
  int k = (SAMPLE_SIZE*freq2)/(SAMPLE_RATE);
  if(raw){
    j=(int)(n);
    k=(int)(n);
  }
  //int j = SAMPLE_SIZE*(n)/(NUM_LEDS)/6+1;
  //int k = SAMPLE_SIZE*((n+1))/(NUM_LEDS)/6+1;
  float sum = 0;
  for(int i=j;i<=k;i++){
    float pw = (sqrt(pow(real_fft_plan->output[2*i+2],2) + pow(real_fft_plan->output[2*i+3],2)));
    sum+=i*pw;
  }
  return audioGain*(sum/((1+k-j))-audioNF);
}



void audioSpectrum(int mo){
  //mic.read(samples);
  
  for (int i = 0 ; i < SAMPLE_SIZE ; i ++) { 
    real_fft_plan->input[i] = (float)(analogReadFast(2)+analogReadFast(2)+analogReadFast(2));
  }
  fft_execute(real_fft_plan); 
  int sumb=0;
  int minPow = 255;
  int maxPow = 0;
  int b=0;
  matrix.fillScreen(0);
  for (int i = 0; i < width; i++) {
    if(i<10){
      b=(int)notepow(i+1,true);
    }else{
      b=(int)notepow(i+34,false);
    }
    
    if(b<0){b=0;}
    if(b>255){b=255;}
    if(b<minPow){minPow=b;}
    if(b>maxPow){maxPow=b;}
    sumb+=b;
    points[i].y=points[i].y*0.5+b*0.5;
    switch(mo){
      case 0:
        matrix.drawLine(i,height,i,(int)(height-points[i].y/8),hsv565(i*4,1,0.125+points[i].y/300));
        break;
      case 1:
        matrix.drawLine(i,height,i,(int)(height-points[i].y/8),hsv565(360-points[i].y,1,0.125+points[i].y/300.0));
        break;
      case 2:
        for(int j=height-1;j>0;j--){
          animFrames[0][j*width+i]=animFrames[0][(j-1)*width+i];
        }
        animFrames[0][i]=hsv565(360-points[i].y*1.4,1,min(1.0,points[i].y/64.0));
        break;
      case 3:
      default:
        if(i%2){continue;}
        for(int j=width-1;j>0;j--){
          animFrames[0][(i/2)*width+j]=animFrames[0][(i/2)*width+j-1];
        }
        animFrames[0][(i/2)*width]=hsv565(360-points[width-1-i].y*1.4,1,min(1.0,points[width-1-i].y/64.0));
        break;
      
    }
  }
  if(mo>=2){
    matrix.drawRGBBitmap(0,0,animFrames[0],64,32);
  }
  matrix.show();
  if(minPow>16 && audioNF<128){
    audioNF*=1.01;
  }
  if(minPow<2 && audioNF>0.01){
    audioNF/=1.01;
  }
  if((sumb/width > 196 || maxPow>=255) && audioGain>0.00001){audioGain*=0.95;Serial.println(String(audioGain,5));}
  if((sumb/width < 32 || maxPow<196)  && audioGain<0.002){audioGain*=1.01;Serial.println(String(audioGain,5));}
  //delay(35);
}

float bigPeak=1025*3;
float bigDC=1024*3;

void audioScope(){
  matrix.fillScreen(0);
  float DC=0;
  float peak=0;
  for(int x=0;x<width;x++){
    animFrames[0][x]=analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2)+analogReadFast(2);
    DC+=animFrames[0][x];
    if(animFrames[0][x]>peak){peak=animFrames[0][x];}
  }
  DC=DC/width;
  bigDC=bigDC*0.99+DC*0.01;
  bigPeak=bigPeak*0.9999;
  if(peak>bigPeak){bigPeak=peak;}
  
  for(int x=0;x<width;x++){
    int y=abs((height/2)*((animFrames[0][x]-bigDC)/(bigPeak-bigDC)));
    if(y>16){y=16;}
    for(int dy=1;dy<=y;dy++){
      if(animFrames[0][x]>DC){
        matrix.drawPixel(x,height/2-dy,hsv565(dy*20,1,1.0*dy/y));
      }else{
        matrix.drawPixel(x,height/2+dy,hsv565(dy*20,1,1.0*dy/y));
      }
    }
  }
  matrix.drawLine(0,height/2,width,height/2,hsv565(0,1,0.125));
  matrix.show();
  delay(15);
}

int whichFrame=0;
uint16_t getCell(int x,int y){
  if(x<0){x+=width;}
  if(x>width-1){x-=width;}
  if(y<0){y+=height;}
  if(y>height-1){y-=height;}
  return animFrames[whichFrame][y*width+x];
}
int nn(int i){
  int x = i%width;
  int y = i/width;
  int count=0;

  if(getCell(x-1,y)){count++;}
  if(getCell(x-1,y-1)){count++;}
  if(getCell(x-1,y+1)){count++;}
  if(getCell(x+1,y)){count++;}
  if(getCell(x+1,y-1)){count++;}
  if(getCell(x+1,y+1)){count++;}
  if(getCell(x,y-1)){count++;}
  if(getCell(x,y+1)){count++;}
  
  return count;
}



void life(){
  int changed=0;
  if(freshSwitch){
    for(int i=0;i<width*height;i++){
      animFrames[0][i]=0;
      animFrames[1][i]=0;
    }
    for(int i=0;i<1024;i++){
      animFrames[!whichFrame][rand()%(width*height)]=hsv565(rand()%(360),1,1);
    }
    freshSwitch=false;
  }else{  
    for(int i=0;i<width*height;i++){
      int numNeighbors = nn(i);
      if(animFrames[whichFrame][i]){
        if(numNeighbors<2){
          animFrames[!whichFrame][i]=0;
          changed++;
          continue;
        }
        if(numNeighbors>3){
          animFrames[!whichFrame][i]=0;
          changed++;
          continue;
        }
        animFrames[!whichFrame][i]=animFrames[whichFrame][i];
      }else{
        if(numNeighbors==3){
          animFrames[!whichFrame][i]=hsv565(rand()%(360),1,1);
          changed++;
          continue;
        }
        animFrames[!whichFrame][i]=0;
      }
    }
    if(millis()-lastCheck>1*60000){
      lastCheck=millis();
      for(int i=0;i<256;i++){
        animFrames[!whichFrame][rand()%(width*height)]=hsv565(rand()%(360),1,1);
      }
    }
    Serial.println(changed);
    if(!changed){
      freshSwitch=true;
    }
  }
  matrix.drawRGBBitmap(0,0,animFrames[!whichFrame],width,height);
  matrix.show();
  whichFrame=1-whichFrame;
  
  delay(33);
}

void brownRainbow(int mm){
  if(freshSwitch){
    for(int i=0;i<width*height;i++){
      animFrames[0][i]=rand()&65535;
      animFrames[1][i]=rand()&65535;
    }
    freshSwitch=false;
  }
  for(int i=0;i<width*height;i++){
    int newColor = animFrames[0][i]+(animFrames[1][i]-32768)/327.767;
    
    if(newColor<0){newColor+=65535;}
    if(newColor>=65535){newColor-=65535;}
    

    animFrames[0][i]=newColor;
    
    if(mm==0){
      matrix.drawPixel(i%width,i/width,hsv565(newColor*0.0055,1,1));
      continue;
    }
    if(mm==1){
      matrix.drawPixel(i%width,i/width,hsv565((millis()/1000)%360,1,0.5+0.5*sin(6.28*(newColor*0.0055)/360.0)));
      continue;
    }
    if(mm==2){
      matrix.drawPixel(i%width,i/width,hsv565((millis()/1000)%360,0.5+0.5*sin(6.28*(newColor*0.0055)/360.0),1));
      continue;
    }
    
  }
  matrix.show();
  //delay(15);
}

int vidIndex=0;

void testPattern(){
  for(;Serial.available()>=3;){
    int r = Serial.read();
    if(r==255){vidIndex=0;continue;}
    int g = Serial.read();
    if(g==255){vidIndex=0;continue;}
    int b = Serial.read();
    if(b==255){vidIndex=0;continue;}
    animFrames[0][vidIndex]=matrix.color565(r,b,g);
    vidIndex++;
    if(vidIndex==width*height){
      matrix.drawRGBBitmap(0,0,animFrames[0],width,height);
      matrix.show();
      vidIndex=0;
      delay(33);
    }
  }
  vidIndex=0;
  for(int x=0;x<width/2;x++){
    for(int y=0;y<height;y++){
      matrix.drawPixel(x+16,y,hsv565((millis()/100)%360,x/32.0,y/32.0));
    }
  }
  matrix.show();
  delay(33);
}

void staticNoise(int ms){
  int oMillis=millis();
  bool m = rand()%2;
  while(millis()-oMillis < ms && millis()-oMillis >= 0){
    if(m){
      for(int i=0;i<width*height;i++){
        int c = rand()%255;
        matrix.drawPixel(i%width,i/width,matrix.color565(c,c,c));
      }
    }else{
      for(int i=0;i<width*height;i++){
        matrix.drawPixel(i%width,i/width,matrix.color565(rand()&255,rand()&255,rand()&255));
      }
    }
    matrix.drawLine(0,height-1-(millis()/30)%height,width,height-1-(millis()/30)%height,0);
    matrix.show();
  }
  
}

void loop() {
  // put your main code here, to run repeatedly:
  
  switch(dMode){
    case 0:
      getMBTA();
      break;
    case 1:
      gMeter();
      break;
    case 2:
      gMeter(true);
      break;
    case 3:
      balls();
      break;
    case 4:
      fluid();
      break;
    case 5:
      audioSpectrum(0);
      break;
    case 6:
      audioSpectrum(1);
      break;
    case 7:
      audioSpectrum(2);
      break;
    case 8:
      audioSpectrum(3);
      break;
    case 9:
      audioScope();
      break;
    case 10:
      life();
      break;
    case 11:
      brownRainbow(0);
      break;
    case 12:
      brownRainbow(1);
      break;
    case 13:
      brownRainbow(2);
      break;
    case 14:
      liveSat("GEOCOLOR");
      break;
    case 15:
      liveSat("Sandwich");
      break;
      
    default:
      testPattern();
  }
  if(!digitalRead(BTN_DOWN)){
    if(dMode>0){
      freshSwitch=true;
      dMode--;
      lastCheck=millis()-5*60000;
      if(dMode==2 || dMode==1){
        for(int i=0;i<numPoints;i++){
          points[i].x=0;
          points[i].y=0;
          points[i].vx=0;
        }
      }
      staticNoise(500);
    }
  }
  if(!digitalRead(BTN_UP)){
    if(dMode<numModes){
      freshSwitch=true;
      dMode++;
      lastCheck=millis()-5*60000;
      if(dMode==2 || dMode==1){
        for(int i=0;i<numPoints;i++){
          points[i].x=0;
          points[i].y=0;
          points[i].vx=0;
        }
      }
      staticNoise(500);
    }
  }
  
}
